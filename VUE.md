> **数据绑定：**

1. 首尾标签内需要绑定的内容用`{{变量名}}`与VUE实例内的data绑定

3. `v-bind：`
   
   - ​    缩写为`:`
   - 
   
3. **数组：[{'键名A'：值'，'键名B'：值}，{'键名A'：值'，'键名B'：值}]**

   对象：{'键名A：值'，'键名B：值'}

4. 

+++

> **渲染：**

1. `v-if`：
   - 常用`<template>`包裹某个布局块，其自身不可见
   - 在多个条件渲染的`<template key="随意值">`如此添加key以区分，在相同的组件也应该添加key，每次切换时，元素都将被重新渲染
2. `v-show`不支持`<template>`元素，也不支持 `v-else`
3. 如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好
4. `v-if`和`v-for`不应该一起使用，`v-for` 具有比 `v-if` 更高的优先级
5. `v-for:`
   1.  `v-for='(元素，键名，索引) of 数组或对象'`
   2. 键名和索引都是可选
   3. 可用于多种标签（常是<li>），写一个标签即可，加上该指令相当于创建多个
   4. 变异方法（实例.数组.方法）：push，pop，shift，unshift，splice，sort，reverse
   5. 非变异：filter，concat，slice
   6. 更改数组长度或修改元素用splice(位置，删除数，新元素)
6. **动态增加某个实例的属性**：`Vue.set(实例.对象名, '键名', 值)`
7. **显示data中定义的变量的修改后的结果：**在方法中定义方法修改该变量，再`v-for='变量 of 方法(原数组)'`

+++

> **事件：**

1. `v-on：`
   1. 缩写为`@事件缩写`
   2. `$event`把当前整个文档作参数传入
   3. 
2. **自定义事件**：
   1. 
3. 侦听：
   1.  `watch:{变量A：function(){},变量B：function(){}}`
   2. 当变量发生改变即执行之后的函数
   3. 使用 `watch` 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态
4. `computed`是基于元素的响应式依赖进行**缓存**的。只在相关响应式依赖发生改变时它们才会重新求值，即若目的对单个或多个元素做不同操作时，才用`methods`
5. 修饰符(使用多个时，先后顺序有影响)：
   - 事件：
     1.  `.stop`
     2. `.native`
     3. `.prevent`
     4. `.capture`
     5. `.self`
     6. `.once`只会被触发一次，除此之外其余的修饰符都不能用于自定义的组件事件
     7. `.passive`
        -  会立即触发而不会等待持续性事件完成，如`onScroll`
        - 尤其能够提升移动端的性能
        - 不能和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告，`.passive` 会告诉浏览器你**不想阻止**事件的默认行为
   - 按键：`@keyup.按键别名或该按键特殊值="函数名"`
   - 系统：
6. 

+++

> 表单：

1. `v-model`
2. ​               

+++

> 组件:

1. 要在<ul>中使用自己定义的组件，要`<li is="组件名">`，因为某些标签只能接受特定的子标签
2. 

