> **特性：**

1. **闭包**：

   1. ```python
      def 外部函数（外部参数）：{
          外部变量
          def 内部函数（内部参数）：
              return 外部变量和内部参数的表达式
          return 内部函数
      }
      变量A=外部函数（参数）
      变量B=变量A（参数）
      ```

   2. 让临时变量在外部函数结束时仍存在，也相当于**偏函数**，可以固定之前自己传入的参数自己生成一个可再次传入参数的新函数

2. **列表生成式:**

   1. `新list=[m + n for m in 'AB' for n in 'XY' if 表达式]`

      新list为`['AX', 'AY', 'BX', 'BY']`，末尾可添加布尔值

      `新list=[a for a in 旧list]`

   2. `新list=[表达式 for a,b in dict.items()]`对于dict分别取出key和value

3. **generator(生成器):**

   1. `储存新序列的一个变量=（m + n for m in 'AB' for n in 'XY'）`把列表生成器的[]改为()

      或

      ```python
      def 生成器函数(){
          ...
          yield 返回值//第n次调用到这里停止，第n+1次运行从这里开始，重复函数
      }
      ```

   2. 相对于列表生成式，生成器每次的调用只生成list中的一个元素`获取单个元素=next(储存新序列的一个变量)`

   3. **为了每次调用生成的结果都和上次不同，且只有一个结果**

   4. 一般只用`for 变量 in 生成器: print(变量表达式)`

   5. 创建一个generator后，基本上永远不会调用`next()`，而是通过`for`循环来迭代它

5. Iterable(可迭代对象):

   -  `for 变量1，变量2，变量3 in [（一维，二维，三维），（一维，二维，三维）]：`
   - 即可用于`for in`，但dict的key和value要自己设方法

5. **Iterator(迭代器)**：

   -  在Iterable的基础上，可用`next()`获取
   -  

6. **lambda(匿名函数):**`变量=lambda 参数1，参数2：参数表达式`

7. **decorator(装饰器):**

   1. ```python
      def 装饰器名(接收函数)://不带参数的装饰器
          @functools.wraps(接收函数)//得导入functools
          def 需要增加的功能(*args,**kw):
              pass
              return 接收函数(*args,**kw)
          return 需要增加的功能
      //先定义装饰器>再安装到目标函数上
      @ 装饰器名
      def 目标函数():
          ... //之后调用目标函数时即有功能增加
      ---------------------------------------------
      def 只负责接收参数的函数(参数)://带参数的装饰器
          def 装饰器名(接收函数)://不带参数的装饰器
              @functools.wraps(接收函数)
              def 需要增加的功能(*args,**kw):
                  pass
               return 接收函数(*args,**kw)
              return 需要增加的功能
          return 装饰器名
      ```
      
   2. **方便为同样类型的几个函数增加相同的功能**

8. **偏函数**:`新函数=functools.partial(原函数，原函数参数=值)`即把原函数的**某个参数固定值，以多次调用**

9. 函数可以有多个返回值

10. 高阶函数：即把函数当作参数传入，不加括号，因为若加括号则变为可执行语句

+++

> **数据类型:**

1. 类型转换:`str()，bool(),int(),float()`布尔转换非空值均转换为True
2. `list:[]>>tuple:()>>dict:{a:1}>>set:{}`
3. 可变类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。
4. 可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。
5. **判断两个对象:**
   -  `is`地址
   - `==`内容
6. 判断是否迭代或迭代器：`isinstance(变量,Iterable或Iterator)`
7. 

+++

> **库：**

1. 操作图像：PIL
2. 爬虫：requests，bs4，Scrapy
3. WEB：flask，django
4. 检测编码：chardet
5. 获取硬件信息：psutil
6. 处理日期：datatime
7. 多种序列：collections
8. 解析HTML：HTMLParser

+++

> **面向对象：**

1. 动态绑定允许我们在程序运行的过程中动态给class加上功能

2. 给实例绑定的属性和方法只是独有，加在类中才是所有实例共享

3. 变量：
   1. 全局变量：在模块内、在所有函数外面、在class外面
   2. 局部变量：在函数内、在class的方法内（未加self修饰的）
   3. 静态变量：在class内的，但不在class的方法内的
   4. 实例变量：在class的方法内的，用self修饰的变量
   5. 私有变量：`__名`，一般是外部不需要的函数或是属性定义
   
4. **函数内调用外部变量：**`global 变量`

5. `__slots__ = ('name', 'age')` 用tuple在类中定义允许绑定的属性名称，且只对当前类有作用，无视继承

6. `__len()__`获取类中元素个数，前提该类的元素表现如同list

7. 多重继承:`class 子类名（父类名1，父类名2）`

8. 内置方法:
   1. `dir()`获取对象属性和方法,返回值为list

      `object._dict_`同上，返回值为dict

   2. `hasattr(obj，属性名)`判断是否拥有该属性或方法

   3. `getattr(obj，属性名)`获得该属性值（包括方法）

   4. `setattr(obj，属性名，值)`设置属性值

   5. `type(object)`和`isinstance(object,类型)`判断所属类

   6. `__init(属性)__{self.属性=值}`相当于JAVA的构造方法，自己设置参数

   7. `len()`计算字符数

   8. `sum(range())`计算总和

   9. `map(作用函数一般用匿名函数，list)`返回值为迭代数，所以还要list()转换为list

   10. `reduce()`

   11. `enumerate(list)`把list转换为带索引的dict
   
9. ``

10. ``

11. **深拷贝**指的是复制内容，单独开辟一个内存

    浅拷贝指的是两个变量同时指向一个内存ID

12. **不定参数**：

+++

> **错误处理：**

1. `try:`

   `except 错误名 as 错误对象:`即java的catch功能

   `else:`如果没有错误才执行

   `finally:`无论是否有错误都执行

2. `with open('路径','选项') as f`

   `print(f.read())`相当于使用try，finall语句，且不必调用`f.close()`

3. 

   